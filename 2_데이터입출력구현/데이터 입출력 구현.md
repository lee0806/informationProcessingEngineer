
> GPT 요약 : 
# **0) 전체 흐름 한눈에 보기**

1. **논리 모델**: “업무 데이터를 말로/그림으로 정리” (무엇을 저장할지)
    
2. **정규화**: “중복/오류 나는 구조 제거”
    
3. **물리 모델**: “DB에 실제로 만들 수 있게 변환” (테이블/컬럼/PK/FK/타입)
    
4. **저장소 설계**: “성능/운영 튜닝 요소” (제약조건, 인덱스, 파티션, 뷰 등)
    
5. **프로시저/함수**: “반복 작업을 DB 안에서 자동으로 처리”
    
6. **최적화**: “실행계획/인덱스/힌트로 빠르게”
    

---

# **1) 논리 데이터 저장소 확인**

  

## **1-1. 논리 데이터 모델링이란?**

- **업무 데이터의 구조와 규칙**을 그림/표로 정확히 표현하는 단계.
    
- “**개념 모델**(대략적) → **논리 모델**(정확한 구조/규칙) → 물리 모델(실제 구현)” 순으로 더 구체화돼요.
    

  

### **핵심 요소(3가지)**

- **개체(Entity)**: 표로 될 대상 (예: 학생, 과목, 주문, 고객)
    
- **속성(Attribute)**: 표의 열(컬럼) (예: 학생.이름, 학생.학번)
    
- **관계(Relationship)**: 표 간 연결(1:N, N:M)
    

  

> **ERD(개체-관계 다이어그램)**:

- > 개체: ■, 관계: ◆, 속성: ○ (기호는 도구마다 조금 달라도 의미는 같아요)
    

  

## **1-2. 정규화(중복/오류 제거 루틴)**

  

**왜 필요?** 중복이 많으면 “삽입/삭제/갱신 이상(Anomaly)”이 생겨요.

- **삽입 이상**: 일부 정보가 없어 **추가 자체**가 안 됨
    
- **삭제 이상**: 쓸모없는 걸 지우다 **필요한 정보까지** 사라짐
    
- **갱신 이상**: 같은 정보가 여러 군데 있어 **한 군데만 고치면 불일치**
    

  

### **단계 요약**

- **1정규형(1NF)**: 한 칸에 **한 값**만(원자값)
    
- **2정규형(2NF)**: **부분 함수 종속** 제거(복합키의 일부만에 종속되는 컬럼 제거)
    
- **3정규형(3NF)**: **이행 함수 종속** 제거(A→B, B→C면 A→C 제거)
    
- **BCNF**: 결정자가 **항상 후보키**가 되도록
    
- **4NF/5NF**: 다치 종속, 조인 종속까지 제거(시험에선 이름/정의 구분 정도)
    

  

> **암기 팁**: “**원부이보사조**”

> 원자값 → 부분종속 → 이행종속 → 보이스코드 → (4,5는 이름/정의 기억)

---

# **2) 물리 데이터 저장소 설계**

  

## **2-1. 논리를 물리로 바꾸는 절차**

1. **개체 → 테이블**
    
2. **속성 → 컬럼**
    
3. **UID(고유식별자) → 기본키(PK)**
    
4. **관계 → 외래키(FK)**
    
5. **컬럼 타입/길이/NOT NULL/DEFAULT** 확정
    
6. **반정규화**(성능 위해 **일부 중복/집계 컬럼** 허용) 검토
    

  

> **예시**

> 논리: 학생(학번, 이름, 반), 과목(과목코드, 과목명), 수강(학번, 과목코드, 성적)

> 물리:

- > 학생(학번 PK, 이름, 반)
    
- > 과목(과목코드 PK, 과목명)
    
- > 수강(학번 FK→학생, 과목코드 FK→과목, 성적, PK=(학번, 과목코드))
    

  

## **2-2. 참조무결성(외래키) 옵션**

- **RESTRICT/NO ACTION(제한)**: 부모 삭제/수정 시, 자식이 있으면 **막음**
    
- **CASCADE(연쇄)**: 부모 삭제/수정 시, 자식도 **같이** 삭제/수정
    
- **SET NULL**: 부모 삭제/수정 시, 자식 FK를 **NULL로**
    

  

> **시험 포인트**: 뜻만 바로 고르기! “연쇄=같이 삭제/갱신”, “널=FK를 NULL”

  

## **2-3. 인덱스(빠른 찾기용 색인)**

- **언제?** 조회 조건/정렬/조인에 자주 쓰는 컬럼
    
- **분포도**(값이 다양하면 좋음) **10~15% 이내**가 효과적이라는 가이드가 자주 나와요.
    
- **PK/UNIQUE** 제약을 걸면 **자동 인덱스** 생성(DB마다 다르지만 흔한 동작)
    

  

### **컬럼 선정 가이드**

- 자주 검색/정렬/조인되는 컬럼
    
- **수정이 잦은 컬럼은 지양**(인덱스 유지비용 큼)
    
- 여러 컬럼을 늘 같이 조건에 쓰면 **결합 인덱스** 고려(순서 중요: **선행 컬럼**이 더 선별적이어야 효과적)
    

  

> **주의**: 인덱스가 많으면 **INSERT/UPDATE/DELETE 느려짐 + 저장공간 증가**

> **함수 적용 컬럼**은 일반 인덱스가 잘 안 타요(함수기반 인덱스 별도)

  

## **2-4. 뷰(View)**

- 복잡한 쿼리를 **가상 테이블**처럼 저장
    
- CREATE OR REPLACE VIEW v_학생A AS SELECT * FROM 학생 WHERE 반='A';
    
- **장점**: 보안(컬럼 제한), 재사용, 쿼리 단순화
    
- **주의**: 조인/집계 포함 뷰는 **업데이트 불가**일 수 있음(DB 규칙)
    

  

## **2-5. 클러스터 & 파티션(운영 성능 설계)**

  

### **클러스터(물리적 근접 저장으로 I/O 줄이기)**

- **대량 범위 조회**/ **자주 조인되는 테이블**에 유리
    
- 읽기는 빨라지지만 **입력/수정/삭제 부하 증가** 가능
    
- UNION/DISTINCT/ORDER BY/GROUP BY가 잦은 컬럼이면 검토 대상
    

  

### **파티션(테이블을 여러 조각으로 나눠 관리)**

- **레인지**(날짜/연속숫자 기준), **해시**(해시함수), **리스트**(명시분류), **컴포지트**(혼합)
    
- **장점**: 대용량에서 **성능/가용성/백업/경합 감소**
    

  

> **시험 포인트**:

- > 레인지=날짜/연속숫자, 해시=균등분산, 리스트=명시적 그룹, 컴포지트=복합
    
- > 장점 4종(성능, 가용성, 백업, 경합감소)
    

---

# **3) 데이터 조작 프로시저(Stored Procedure)**

  

## **3-1. 개념**

- SQL 묶음을 **DB 안에 저장해 두고** 호출/자동 실행하는 **프로그램 단위**
    
- 반복 작업/트랜잭션/검증 로직을 DB 가까이에 둬서 **네트워크 왕복/응용 복잡도**를 줄임
    
- Oracle: **PL/SQL**, PostgreSQL: PL/pgSQL, MySQL: Stored Procedure
    

  

## **3-2. PL/SQL(Oracle) 아주 간단 예시**

```
-- 출력 켜기(툴에서 1번만)
SET SERVEROUTPUT ON;

-- 프로시저 생성
CREATE OR REPLACE PROCEDURE P_HELLO AS
BEGIN
  DBMS_OUTPUT.PUT_LINE('안녕하세요!');
END;
/

-- 실행
EXEC P_HELLO;
```

> **DBMS_OUTPUT.PUT_LINE**: 프로시저 내부 값 확인용(로그 찍기)

> 에러 나면 SHOW ERRORS로 확인(툴/환경에 따라 명령이 다를 수 있어요)

  

## **3-3. (참고) 애플리케이션과 연결 흐름**

- JDBC(자바) 예: **드라이버 로딩 → 연결 → SQL 전달 → 결과 받기**
    
- 시험에선 **순서/역할**만 기억하세요.
    

---

# **4) 성능 최적화(실행 계획/옵티마이저/힌트)**

  

## **4-1. SQL 성능 개선 절차(정석)**

1. **문제 SQL 식별**(APM/로그/상위쿼리)
    
2. **통계 확인**(테이블/인덱스 통계 최신화 여부)
    
3. **SQL 재구성**(필요 없는 컬럼 제거, 조인 순서/조건 최적화, 서브쿼리→조인 등)
    
4. **인덱스 재설계**(컬럼/순서/선행조건)
    
5. **실행계획 유지/검증**(Plan Baseline/히스토그램 등, DB별 기능)
    

  

## **4-2. 옵티마이저(Optimizer)**

- DB 내부의 “**최적 경로 탐색 엔진**”
    
- 역할: **쿼리 변환 → 비용 산정 → 실행계획 생성**
    
- 유형:
    
    - **RBO**(규칙기반): 룰에 따라 결정(요즘은 거의 사용 안 함)
        
    - **CBO**(비용기반): 통계 기반으로 가장 싸게(**현대 DB의 표준**)
        
    

  

## **4-3. 힌트(Hint) – 실행 계획에 조언 주기 (Oracle 표기 예)**

```
-- 특정 인덱스 쓰도록 강제
SELECT /*+ INDEX(사원 IDX_사원_부서) */ *
FROM 사원
WHERE 부서번호 = 10;

-- 조인 방식 유도
SELECT /*+ USE_HASH(A B) */ ...
SELECT /*+ USE_MERGE(A B) */ ...
SELECT /*+ USE_NL(A B)   */ ...
```

- **INDEX**: 특정 인덱스 사용
    
- **USE_HASH / USE_MERGE / USE_NL**: 해시/정렬병합/네스티드루프 조인 선택
    
- RULE, CHOOSE 같은 옛 힌트는 시험에서 **의미만** 알아두면 충분
    

  

> **주의**: 힌트는 “마지막 수단”. 먼저 **통계 최신화/쿼리/인덱스**를 점검하세요.

---

# **5) 초간단 실전 미션(직접 타이핑용)**

1. 테이블 만들기
    

```
CREATE TABLE 학생 (
  학번 INT PRIMARY KEY,
  이름 VARCHAR(20) NOT NULL,
  반   CHAR(1)     NOT NULL
);
```

2. 데이터 넣기
    

```
INSERT INTO 학생 VALUES (1, '민지', 'A');
INSERT INTO 학생 VALUES (2, '철수', 'A');
INSERT INTO 학생 VALUES (3, '영희', 'B');
```

3. 조회/그룹/정렬
    

```
SELECT * FROM 학생;
SELECT 반, COUNT(*) 인원 FROM 학생 GROUP BY 반;
SELECT 이름 FROM 학생 WHERE 반='A' ORDER BY 이름;
```

4. 인덱스/뷰
    

```
CREATE INDEX IDX_학생_반 ON 학생(반);
CREATE OR REPLACE VIEW V_A반 AS SELECT * FROM 학생 WHERE 반='A';
```

5. 프로시저(Oracle)
    

```
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE P_반카운트 AS
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM 학생 WHERE 반='A';
  DBMS_OUTPUT.PUT_LINE('A반 인원=' || v_cnt);
END;
/
EXEC P_반카운트;
```

---

# **6) 시험용 핵심 암기 체크**

- **정규화**: 1NF(원자값) → 2NF(부분종속X) → 3NF(이행종속X) → BCNF(결정자=후보키)
    
- **FK 옵션**: 제한(막음) / 연쇄(같이) / SET NULL(널 처리)
    
- **인덱스**: 조회/조인/정렬 컬럼, **분포도 좋을수록**, 수정 잦으면 역효과
    
- **파티션 종류**: 레인지/해시/리스트/컴포지트 (장점: 성능·가용성·백업·경합↓)
    
- **프로시저**: DB 내부 자동/재사용 로직(PL/SQL 등)
    
- **옵티마이저**: CBO가 표준, 실행계획은 통계에 좌우
    
- **힌트**: INDEX / USE_HASH / USE_MERGE / USE_NL 의미만 정확히
    

---


### 현행 시스템 분석

**현행시스템 파악**

현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동. 사용하고 있는 소프트웨어 및 하드웨어는 무엇인지, 네트워크의 구성은 어떻게 되어 있는지 파악하는 활동

```

“대학교 학생 관리 시스템”을 새로 만든다고 가정해보자.

그럼 먼저 이렇게 물어봐야 해요 👇

- 지금 사용하는 시스템은 어떤 프로그램들로 이루어져 있나요?
    
    (예: 학생관리, 성적조회, 출석체크, 장학금 관리 등)
    
- 각각이 어떤 기능을 하나요?
    
    (예: 성적조회 시스템 → 학생별 성적 출력, 학과별 통계)
    
- 이 시스템들은 서로 연결되어 있나요?
    
    (예: 수강신청 시스템과 성적 시스템이 연결됨)
    
- 어떤 기술이 쓰이고 있나요?
    
    (예: DB는 MySQL, 프론트는 React, 서버는 Spring Boot)
    
- 서버는 어디에 있나요? 네트워크 구조는요?
    
    (예: 학교 내부망 서버 + 교직원만 접근 가능)


👉 이렇게 전부 파악해야 새 시스템을 “뭐부터 개선할지” 정할 수 있어요.
```

**현행 시스템 파악 절차**

1. 구성 / 기능 / 인터페이스 파악
	시스템이 어떤 하위 시스템으로 구성되어 있고, 어떤 기능을 제공하며, 서로 어떤 방식으로 데이터를 주고 받는지 확인
2. 아키텍처 및 소프트웨어 구성 파악
	시스템 구조(계층, 모듈 구조)와 같이 사용중인 개발 언어, 프레임워크, DB, 운영체제 등을 파악
3. 하드웨어 및 네트워크 구성 파악
	서버, 저장장치, 네트워크 연결 구조, 보안 장비 등을 파악

**소프트웨어 아키텍처**

여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체를 의미. 소프트웨어를 설계하고 전개하기 위한 지침이나 원칙

> 시스템의 큰 구조와 원칙을 의미

**소프트웨어 아키텍처 프레임워크**

집약적인 소프트웨어 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준

**소프트웨어 아키텍처 프레임워크 구성요소**

- 아키텍처 명세서 : 아키텍처를 기록하기 위한 산출물 (시스템 구성도, 아키텍처 다이어그램)
- 이해관계자 : 시스템 개발에 관련된 모든 사람과 조직 (사용자, 개발자, 운영자, 관리자 등)
- 관심사 : 시스템에 대해 이해관계자들의 서로 다른 의견, 목표 (보안, 성능, 유지보수성, 편의성)
- 관점 : 개별 뷰를 개발할 때 토대가 되는 패턴, 양식 (기능 중심 / 구조 중심 / 배포 중심)
- 뷰 : 서로 관련 잇는 관심사들의 집합 (논리 뷰, 프로세스 뷰, 배포 뷰 등)
- 근거 : 아키텍처 결정 근거, 회의 보고 결과 (성능 향상을 위해 캐시 구조를 추가한다와 같은 근거)

**소프트웨어 아키텍처 4 + 1 뷰**

고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법, 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를 증명하기 위해 체크 방법으로 유스케이스를 사용

**소프트웨어 아키텍처 4 + 1 뷰 구성 요소**

4 + 1에서 1은 유스케이스 뷰, 4는 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰이다.

- 유스케이스 뷰 : 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰, 다른 뷰를 검증하는 데 사용 (시스템이 해야 하는 일 중심)
- 논리 뷰 : 설계 모델의 추상화이며, 주요 설계 패키지와 서브 시스템, 클래스를 식별하는 뷰. 시스템의 기능적인 요구사항 지원, 클래스와 이들 간 관계에 대한 집합을 보여주는 클래스 다이어그램으로 표현 (무엇을 해야하는지 중심)
- 프로세스 뷰 : 런타임 시의 시스템의 테스크, 스레드, 프로세스와 이들 사이의 상호작용 등의 관계를 표현하는 뷰 (어떻게 동작 시키는지 중심)
- 구현 뷰 : 코드, 패키지, 컴포넌트 구조 (소스코드 관리 / 개발 구조 중심)
- 배포 뷰 : 물리적인 노드의 구성과 상호 연결 관계를 배포 다이어그램으로 표현하는 뷰, 다양한 실행 파일과 다른 런타임 컴포넌트가 해당 플랫폼 또는 컴퓨팅 노드에 어떻게 매핑되는가를 보여주며, 가용성, 신뢰성, 성능, 확장성 등의 시스템의 비기능적인 요구사항을 고려 (어디서 어떻게 설치되나 중심)

```
예시 (메신지 어플 예시)

유스케이스 뷰 : 사용자는 메시지를 보내고, 친구 추가를 한다.
논리 뷰 : 메시지 전송 클래스, 친구 관리 클래스, 채팅방 클래스 등
프로세스 뷰 : 메시지 서버 프로세스, 알림 서버 프로세스가 동시에 동작
구현 뷰 : chat-service, user-service 등 각각의 코드 모듈로 구성
배포 뷰 : 앱 서버, DB 서버, 메시지 서버 등 물리적으로 분리
```

### 개발 기술 환경 정의

**운영 체제**

컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램

- macOS, windowOS, Linux 등등...

**운영체제 현행 시스템 분석 시 고려 사항**

- 신뢰도
- 성능
- 기술 지원
- 주변 기기
- 구축 비용

**네트워크**

컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술, 데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이와 같은 무선 매체를 통해 확립된다.

**OSI 7계층(물데네전세표응)**

네트워크 통신에서 생긴 여러 가지 충돌 문제를 완하하기 위해 국제 표준화 기구에서 제시한 네트워크 기본 모델

- 물리 계층 (비트 단위) (랜선, 광케이블) 
- 데이터 링크 계층 (프레임 단위) (이더넷, 스위치, 오류 검출)
- 네트워크 계층 (패킷 단위) (IP, 라우터)
- 전송 계층 (세그먼트 단위) (TCP, UDP)
- 세션 계층 (데이터 단위 이상) (로그인 세션, 화상회의 연결)
- 표현 계층 (텍스트 인코딩, 이미지 압축, 데이터 암호화)
- 응용 계층 (웹 브라우저, 이메일, 파일 전송)

**DBMS (Database Management System)**

데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램

기능
- 중복 제어
- 접근 통제
- 인터페이스 제공
- 관계 표현

**현행 시스템 분석**

데이터베이스의 가용성, 성능, 기술 지원, 호환성, 구축 비용을 분석한다.

**미들웨어**

미들웨어는 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어이다. 운영체제와 소프트웨어 애플리케이션 사이에 위치하며 대표적으로 WAS로 예를 들 수 있다.

```
응용 프로그램과 운영체제는 직접 통신하지 않음
그 사이에서 중간 전달자 역할을 하는데 그게 미들웨어임

[사용자]  

   ↓  

[응용 프로그램]  ← (예: 쇼핑몰, 카카오톡, 은행 웹사이트)

   ↓  

[미들웨어]      ← (예: WAS, 메시지큐, API 게이트웨이)

   ↓  

[운영체제(OS)]  ← (예: Windows, Linux)

   ↓  

[하드웨어/서버]
```


**현행 시스템 분석** 

미들웨어의 가용성, 성능, 기술 지원, 구축 비용을 분석한다.

**웹 애플리케이션 서버 (WAS : Web Application Server)**

웹 애플리케이션 서버는 서버 계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이 기종 시스템과의 애플리케이션 연동을 지원하는 서버

```
미들웨어 중 하나의 예시 

|**상용 WAS**|WebLogic, WebSphere|

|**오픈소스 WAS**|Apache Tomcat, JBoss, Jetty|
```


**온라인 트랜잭션 처리 (OLTP) 시스템**

네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식

### 요구사항 확인

**요구사항**

문제의 해결 또는 목적 달성을 위하여 고객에 의해 요구되거나, 표준이나 명세 등을 만족하기 위하여 시스템이 가져야 하는 서비스 또는 제약 사항

```
"시스템이 반드시 해야하는 일", "지켜야 할 조건"
고객이 원하는 서비스나 제약 사항을 뜻함
```

**기능적 요구사항 시스템이 제공하는 기능** 

서비스에 대한 요구사항

```
시스템이 무엇을 해야 하는지에 대한 요구사항

"회원가입이 가능해야 한다" - 사용자 기능
"관리자는 학생 정보를 수정할 수 있어야 한다" - 관리 기능
"출석 기록을 조회할 수 있어야 한다" - 서비스 기능
```

기능적 요구사항의 특성

- 기능성 - 원하는 기능을 실제로 제공해야 함
- 완전성 - 필요한 기능이 빠짐없이 포함되어야 함
- 일관성 - 서로 충돌되지 않아야 함

**비기능적 요구사항 시스템이 수행하는 기능**

기능적 요구사항 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항

```
시스템이 어떻게 동작해야 하는지에 대한 요구사항

"로그인 응답 속도는 2초 이내여야 한다" - 성능 요구사항
"비밀번호는 암호화되어 저장되어야 한다" - 보안 요구사항
"모바일 환경에서도 동작되어야 한다" - 호환성 요구사항
"시스템은 하루 24시간 중단 없이 동작되어야 한다" - 신뢰성 요구사항
```

비기능적 요구사항의 특성

- 신뢰성 - 요류 없이 안정적으로 동작
- 사용성 - 사용하기 쉬운 인터페이스
- 효율성 - 빠른 응답시간, 적은 자원 사용
- 유지보수성 - 수정 / 업데이트가 쉬움
- 이식성 - 다른 환경에서도 동작되어야함

**요구사항 개발 프로세스**

1. 도출 - 사용자가 원하는 걸 찾아내는 과정
2. 분석 - 요구사항을 정리하고 중복, 모호, 충돌을 제거
3. 명세 - 분석된 요구사항을 문서로 정리
4. 확인 - 요구사항이 고객이 원하는 것인지 검증

**요구사항 개발 프로세스 주요 기법**

1. 도출 
- 인터뷰
- 설문 조사
- 브레인 스토밍 (아이디어 회의)
- 워크 숍

2. 분석 
- 자료 흐름 지향 분석 : DFD(Data Flow Diagram)으로부터 소프트웨어 구조를 유도
- 객체지향 분석

3. 확인 및 검증
- 동료 검토
- 워크 스루 : 자료를 사전 배포 및 검토 후 짧은 시간 회의
- 인스펙션 : 저작자 외의 다른 전문가 or 팀이 검사하여 오류를 찾음

**요구사항 관리 프로세스**

- 요구사항 협상 - 고객과 개발자가 서로 타협
- 요구사항 기준선 - 변경이 허용되지 않는 확정본 설정
- 요구사항 변경 관리 - 변경 요청 -> 검토 -> 승인 / 반려 절차
- 요구사항 확인 및 검증 - 변경된 요구사항이 문제 없는지 재확인

**요구사항 분석 기법**

- 요구사항 분류 : 기능인지 비기능인지
- 개념 모델링 : 엔티티들과 개별 관계 및 종속성 반영, 유스케이스 다이어그램, UML 사용 (데이터 간 관계 모델링 (UML, ERD))
- 요구사항 할당 : 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별, 추가 요구사항의 발견 (기능을 아키텍처 요소에 연결)
- 요구사항 협상 : 적절한 지점 합의 (상충되는 요구를 조율)
- 정형 분석 : 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현 (수학적 / 형식적 언어로 명확하게 표현)

**UML (Unified Modeling Language)**

객체지향 소프트웨어 개발과정에서 산출물을 명세화, 시각화, 문서화할 시 사용되는 모델링 기술과 방법론을 통합해 만든 표준화된 범용 모델링 언어

```
시스템의 구조를 그림으로 표현하는 표준 언어

유스케이스 다이어그램 : 사용자와 시스템의 상호작용 표현
클래스 다이어그램 : 객체(클래스)와 관계 표현
시퀀스 다이어그램 : 객체 간 메시지 흐름 (시간 순서)
상태 다이어그램 : 객체의 상태 변화 표현
```

**요구사항 확인 기법**

- 요구사항 검토 (문서 기반의 검토로, 개발자 / 기획자가 회의하여 검토함)
- 프로토 타이핑 : 프로토 타입으로 구현, 사용자의 피드백을 통해 개선 및 보완 (화면 목업, 기초적으로 구성된 프로토 타입을 피드백을 통해 개선)
- 모델 검증 (클래스 간 관계 오류를 확인) 
- 인수 테스트 (고객이 테스트 후 승인)

**요구사항 확인 프로세스**

- 요구사항 목록 확인 (모든 요구사항이 반영되었는지 확인)
- 요구사항 정의서 작성 여부 확인 (문서화된 서류가 있는지 확인)
- 비기능적 요구사항의 확인 (성능, 보안, 품질 등 비기능적 요구사항이 지켜졌는지 확인)
- 타 시스템 연계 및 인터페이스 요구사항 확인 (기존 시스템, API 연동 문제가 없는지 확인)

### 요구사항의 시스템화 타당성 분석

```
이 요구사항을 기술적으로 구현 가능한가를 검토
```

**요구사항의 기술적 타당성 검토**

- 성능 및 용량 산정의 적정성 (모든 데이터를 저장할 수 있는가?, 성능에 문제가 없는가?)
- 시스템 간 상호 운용성 (시스템 간 연결이 가능한가?)
- IT 시장 성숙도 및 트렌드 부합성 (안정적인 기술인가?)
- 기술적 위험 분석 (개인정보 유출, 기술적 취약점이 존재하지 않는가?)

**요구사항의 기술적 타당성 분석 프로세스**

- 타당성 분석 결과 기록 (감토한 결과를 문서로 정리)
- 타당성 분석 결과의 이해관계자 검증 (관련 사람이 검토)
- 타당성 분석 결과 확인 및 배포 / 공유 (확정된 사항을 팀 전체에 공유)

### 비용산정 모델

```
시스템을 개발하는 데 필요한 '돈과 인력, 시간'을 예측하는 방법

"프로젝트를 완성하기 위해 얼마나 비용이 들까?"를 계산하는 과정
```

**비용산정 모델 분류**

**하양식 산정방법** 

경험이 많은 전문가에게 비용산정을 의뢰하거나 여러 전문가와 조정자를 통해 산정하는 방식

```
전문가의 경험이나 회의로 결정되는 방식, 세부적인 계산보다 "전체적인 감"으로 판단
```

- 전문가 판단 (경험이 많은 전문가의 직관에 의한 추정)
- 델파이 기법 (여러 전문가의 의견을 모아 합의점 도출)

**상향식 산정방법**

세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식

```
실제 개발할 기능, 코드, 인력, 기간을 하나씩 쪼개서 계산하는 구체적이고 객관적인 방식
```

- LOC (Lines of Code) (필요한 코드의 줄 수(라인 수)로 계산)
- Man Month (M / M) (한 사람이 한 달동안 할 수 있는 일의 양 기준)
- CoCoMo 모형 (코드량(LOC)을 기반으로 프로젝트 유형별로 계산)
- Putnam 모형 (시간에 따른 노력 분포 곡선으로 계산)
- FP (Function Point) 모형 (기능 수를 기준으로 계산, 코드 줄 수 보다 실질적)

**Man Month**

한 사람이 1개월동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 기법

Man Month = LoC / 프로그래머의 월간 생산성
프로젝트 기간 = Man Month / 프로젝트 인력

```
프로그램 전체 코드 양 (LOC) = 10,000줄

한사람이 한 달에 1,000줄 작성 가능
Man Month = 10,000 / 1,000 = 10M/M
즉 총 10인월 이 필요
1명이면 10개월
2명이면 5개월
...
```

**CoCoMo**

- 단순형 (Organic Mode) : 5만 라인 이하, 일괄 자료 처리, 과학 기술 계산용, 비즈니스 자료 처리 개발 (소규모, 단순 업무 처리) (개인용)
- 중간형 (Semi-Detached Mode) : 30만 라인 이하, 데이터베이스 관리 시스템 개발 (중간 규모, 팀 기반 DB 설계) (회사용 재고 관리 시스템 등...)
- 임베디드형 (Embedded Mode) : 30만 라인 이상, 트랜잭션 처리 시스템 운영체제 개발 (대규모, 제약이 많음) (운영체제, 트랜잭션 시스템 등...)

### 분석 모델 확인하기

```
요구사항을 바탕으로 만든 분석 모델이 정확한지, 문제가 없는지 검토
```

**분석 모델 검증**

요구사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동

**분석 모델 검증 방법**

- 유스케이스 모델 검증 (사용자의 행동이 제대로 반영되었는가?)
- 개념 수준의 분석 클래스 검증 (객체들 간 관계가 올바른가?)
- 분석 클래스 검증 (클래스 속성과 메서드가 정확한가?)

**분석 클래스의 스테레오 타입**

- 경계 : 시스템과 외부 액터와의 상호작용을 담당하는 클래스 (사용자와 시스템이 만나는 접점) (로그인 화면, 각종 컴포넌트)
- 엔티티 : 시스템이 유지해야 하는 정보를 관리하는 기능을 전담하는 클래스 (데이터를 저장하고 관리) (학생, 과목, 성적 데이터)
- 제어 : 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스 (로직이나 흐름 제어) (출석 확인 로직, 결제 처리 로직)

**분석 모델 검증 프로세스**

1. 검토의견 컬럼 추가 
2. 검토의견 작성
3. 검토의견 정제

### 분석 모델의 시스템화 타당성 분석

분석 모델이 개발할 응용 소프트웨어에 미칠 영향을 검토하여 기술적인 타당성을 조사

**분석 모델의 기술적 타당성 검토 항목**

- 성능 및 용량 산정의 적정성 (실제 시스템이 감당할 수 있는가?)
- 시스템 간 상호 운용성 (기존 시스템과 호환이 가능한가?)
- IT 시장 성숙도 및 트렌드 부합성 (사용하는 기술이 안정적인가?)
- 기술 위험 분석 (실패, 오류, 보안 이슈가 없는가?)

**분석 모델의 시스템화 타당성 분석 프로세스**

1. 타당성 검토의견 컬럼 추가
2. 타당성 검토의견 작성
3. 타당성 분석 결과 검증
4. 타당성 분석 결과 확인 및 배포 / 공유


**결합도의 종류와 강도**

결합 강도가 가장 높은것부터 낮은 것까지

1. 내용 결합도 : 한 모듈이 다른 모듈 내부의 변수나 기능을 직접 참조
2. 공통 결합도 : 여러 모듈이 전역 변수 (Global Variable)를 공유
3. 외부 결합도 : 모듈이 외부 시스템, 파일, 장치 등과 상호작용
4. 제어 결합도 : 제어 신호를 전달하여 흐름 제어
5. 스탬프 결합도 : 자료 구조를 매개변수로 전달
6. 자료 결합도 : 단순한 데이터 값을 인자로 전달

내변, 공전, 외외, 제제, 스자, 자단

내공외제스자
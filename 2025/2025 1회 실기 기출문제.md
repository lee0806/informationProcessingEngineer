
### 1. 다음은 네트워크 보완에 관련된 문제이다. 괄호안에 알맞는 용어를 작성하시오.

(   )은/는 '세션을 가로채다.' 라는 의미로 다른 사람의 세션 상태를 훔치거나 도용하여 액세스하는 해킹 기법이다. 

TCP (   )은/는 TCP의 3-way 핸드셰이크가 완료된 후에 공격자가 시퀀스 번호 등을 조작하여 정상적인 세션을 가로채고 인증 없이 통신을 탈취하는 공격 공격이다.

> 세션 하이재킹


### 2. 다음은 제약조건과 관련된 문제이다. 괄호안에 알맞는 용어를 보기에 골라 작성하시오.

![](https://blog.kakaocdn.net/dna/zQKG3/btsNAiF6b8L/AAAAAAAAAAAAAAAAAAAAAEa_W4EUTDLlkXQKJW6z5pdQtR8cuby6AE9Gn06UIVEM/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=4HgxP9qekGDq%2BKffYTjN4D393zw%3D)

**[보기]**

개체, 참조, 도메인

> 도메인, 개체, 참조

### 3. 아래의 내용에서 설명 글의 괄호안의 용어를 영문 약자로 작성하시오.

(        ) 은/는 3글자의 영어 약자로 이루어진 오류 기법으로 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하는 데 사용되는 오류 검출 코드이다.

  
(        ) 은/는 데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인하는 기법이다.

  
(        ) 은/는 데이터 전송의 안정성을 높이는 데 중요한 역할을 한다.

  
데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x³ + x + 1)을 기반으로 데이터를 2진수 나눗셈하고나머지를 (       ) 값으로 삼는다.

> ICMP
> 정답 : CRC

### 4. 다음은 악성코드 관련된 문제이다. 아래 내용을 확인하여 보기에 골라 작성하시오.  
  
  
사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.  
  
‘겁을 주다’라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불 하거나 특정 행동을 유도하는 랜섬웨어이다.  
  
가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다. 

**보기**

ㄱ. 컴포넌트 웨어  ㄴ. 유즈웨어  ㄷ. 셔블웨어  ㄹ. 스캐어 웨어  ㅁ. 안티 스파이 웨어  ㅂ. 네트웨어  ㅅ. 그룹웨어  ㅇ. 애드웨어

> ㄹ

### 5. 다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
public class Main {

  public static void main(String[] args) {

    int a=5,b=0;

    try{

      System.out.print(a/b);

    }catch(ArithmeticException e){

      System.out.print("출력1");

    }catch(ArrayIndexOutOfBoundsException e) {

      System.out.print("출력2");

    }catch(NumberFormatException e) {

      System.out.print("출력3");

    }catch(Exception e){

      System.out.print("출력4");

    }finally{

      System.out.print("출력5");

    }

  }

}
```

> 출력1출력5

> 정수 나눗셈에서 0으로 나누면 ArithmeticException이 발생한다.
> try 블록에서 예외가 발생하고 일치하는 catch로 이동한다.
> ArithmeticException e이므로 첫번째 catch가 실행된다.
> 그 뒤 finally 블록은 예외 발생 여부와 상관없이 항상 실행된다.
> 따라서 "출력1출력5"가 나오게 된다.


### 6. 아래 내용은 ARP/RARP에 대한 설명이다. 각 설명에 해당하는 것을 작성하시오.

  
( 1 ) 은/는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜이고,

( 2 ) 은/는 MAC 주소를 IP 주소로 변환하는 프로토콜이다.

> 1. ARP 2. RARP

  
### 7. 다음은 SQL 문제이다. 아래 두 테이블을 참고하여 보기에 쿼리 실행 결과를 작성하시오.

![](https://blog.kakaocdn.net/dna/F7Tnq/btsNzZtANQz/AAAAAAAAAAAAAAAAAAAAAK1cx-4kJpaMoUmRFCPQDT5G_pIphsY5oeoaQzKY76x6/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=DRWtDB55DqZRiIX2GBhFQyv%2BnO8%3D)

**[보기]**

SELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500

> name | incentive
> 이순신 | 1000
> 

### 8. 아래는 데이터베이스에 관련된 설명이다. 알맞는 용어를 보기에서 골라 괄호를 작성하시오.
  
  
1. 릴레이션에서 속성의 개수를 의미 : ( 1 )  
  
2. 릴레이션에서 튜플의 개수를 의미 : ( 2 )  
  
3. 한 릴레이션의 속상이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미 : ( 3 )  
  
4. 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준 : ( 4 )

**[보기]**

ㄱ. domain   ㄴ. primary   ㄷ. degree    ㄹ. candidate   ㅁ. cardinality   ㅂ. attribute   ㅅ. foreign

>1. ㄷ 2. ㅁ 3. ㅅ 4. ㄱ

> domain (도메인) : 속성(Attribute)에 저장할 수 있는 값의 범위를 정의한 것 (성별(gender)의 도메인 => 'M', 'F')
> primary (기본키) : 테이블 내에서 각 튜플(행)을 고유하게 식별할 수 있는 키, NULL 불가, 중복 불가
> degree (디그리) : 속성(열)의 개수. 테이블 구조(스키마) 측면에서 테이블이 몇 개의 필드를 갖는지 나타냄
> candidate (후보키) : 기본키로 선택될 수 있는 속성들의 집합, 여러 후보키 중에서 하나가 기본키로 선택됨
> cardinality (카디널리티) : 튜플(행)의 개수, 테이블에 실제 저장된 데이터의 개수를 의미
> attribute (속성) : 테이블의 열(column), 데이터의 성질(특징)을 표현하는 항복
> foreign (외래키) : 다른 릴레이션(테이블)의 기본키를 참조하는 키, 테이블 간 참조 무결성 유지에 사용

### 9. IP 주소가 192.168.35.10, 서브넷 255.255.252.0인 PC에서 브로드캐스팅으로 다른 IP로 정보를 전달한다고 할 때 수신할 수 있는 알맞는 IP를 보기에서 골라 모두 작성하시오.

  
**[보기]**  
  
ㄱ. 192.168.34.1   
ㄴ. 192.168.32.19  
ㄷ. 192.168.35.200  
ㄹ. 192.168.33.138  
ㅁ. 192.168.35.50

> ㄱ,ㄴ,ㄷ,ㄹ,ㅁ

> 수신 가능한 IP는 192.168.32.1 ~ 192.168.35.254까지 이므로 모두 가능하다.


### 10. 다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
#include <stdio.h>

char Data[5] = {'B', 'A', 'D', 'E'};

char c;

int main(){

    int i, temp, temp2;

    c = 'C';

    printf("%d\n", Data[3]-Data[1]);

    for(i=0;i<5;++i){

        if(Data[i]>c)

            break;

    }

    temp = Data[i];

    Data[i] = c;

    i++;

    for(;i<5;++i){

        temp2 = Data[i];

        Data[i] = temp;

        temp = temp2;

    }

    for(i=0;i<5;i++){

        printf("%c", Data[i]);

    }

}
```

> 4
> BACDE

> 첫번째 printf는 문자 'E' - 'A'이므로 숫자로 변환하여 뺀 값 4가 출력됨
> 첫번째 for문을 통해 i는 'C'보다 큰 값인 'D' 즉 i = 2에서 멈춤
> temp = Data[i]이므로 temp = 'D'
> Data[2] = c; 이므로 Data[2] = 'C';
> 다음 for 문을 통해 문자 변환
> 따라서 Data 배열에는 BACDE 순서로 저장됨
> 마지막 for문을 통해 배열 출력

### 11. 다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
#include <stdio.h>

#include <stdlib.h>

void set(int** arr, int* data, int rows, int cols) {

    for (int i = 0; i < rows * cols; ++i) {

        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];

    }

}

int main() {

    int rows = 3, cols = 3, sum = 0;

    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; 

    int** arr;

    arr = (int**) malloc(sizeof(int*) * rows);

    for (int i = 0; i < cols; i++) {

        arr[i] = (int*) malloc(sizeof(int) * cols);

    }

    set(arr, data, rows, cols);

    for (int i = 0; i < rows * cols; i++) {

        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);

    }

    for(int i=0; i<rows; i++) {

        free(arr[i]);

    }

    free(arr);

    printf("%d", sum);

}
```



### 12. 다음은 결합도와 관련된 내용이다. 보기에 알맞는 답을 골라 작성하시오.
  
(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도  
  
(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도  
  
(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도    
  
**[보기]**  
  
ㄱ. 자료 결합도  ㄴ. 스탬프 결합도 ㄷ. 제어 결합도  ㄹ. 공통 결합도  ㅁ. 내용 결합도  ㅂ. 외부 결합도

> 1. ㅁ, 2. ㄴ, 3. ㄹ


### 13. 다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
public class Main {

    public static void main(String[] args) {

        new Child();

        System.out.println(Parent.total);

    }

}

class Parent {

    static int total = 0;

    int v = 1;

    public Parent() {

        total += (++v);

        show();    

    }

    public void show() {

        total += total;

    }

}

class Child extends Parent {

    int v = 10;

    public Child() {

        v += 2;

        total += v++;

        show();

    }

    @Override

    public void show() {

        total += total * 2;

    }

}
```

>  54

> 부모 필드 -> 부모 생성자 -> 자식 필드 -> 자식 생성자의 순서로 실행
> new Child를 통해 부모부터 초기화를 진행

> 따라서
> total = total + ++(1);
> show(); <- 이때 show는 override 되었으므로 자식 메서드 호출
> total = total + total * 2
> total = 2 + 2 * 2 == 6
> 이후 자식 필드 초기화 후 생성
> v = v + 2 == 12
> total = total + 12++; -> 6 + 12 == 18
> total = 18 + 18 * 2 == 따라서 54


### 14. 아래는 디자인 패턴에 대한 설명이다. 알맞는 답을 보기에 골라 작성하시오.
  
  
서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다.  
  
기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다.  
  
기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다.

![](https://blog.kakaocdn.net/dna/oCM2H/btsNzMAY2Vl/AAAAAAAAAAAAAAAAAAAAAI7nU4pEShdC4QU1bezXWzN8QaWWxsCQJI6lxs7fAj-m/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=mkV1xM40e%2BBsuM8xKfqefWAMwGk%3D)

> Adapter


### 15. 문장(Statement) 커버리지 테스트를 수행하려고 한다. 코드를 아래의 제어 흐름도 빈칸에 연결되도록 작성하고 문장 커버리지 순서대로 작성하시오.

```
int Main(int b[], int m, int x) {

    int a = 0;

    while (a < m || b[a] < x) {

        if (b[a] < 0)

            b[a] = -b[a];

        a++;

    }

    return 1;

}
```

![](https://blog.kakaocdn.net/dna/dK8Uvu/btsNBHY9xSO/AAAAAAAAAAAAAAAAAAAAALKBOe-hfTV3FscLa7xdAqX4hNMqJ41TcqTsgB1SHIEc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=lZMygOIVhvJGj%2Bnkm60CeKvhoRk%3D)

1. (    ①    )    2. (    ②    )    3. (    ③    )    4. (    ④    )    5. (    ⑤    )  6. (    ⑥    )

문장 커버리지 순서 1 → 2  → (          ⑦           )

>
> int a = 0;
> while (a < m || b[a] < x)
> if (b[a] < 0)
> b[a] = -b[a];
> a++;
> return 1;
> 
> 3 -> 4 -> 5 ->2 -> 6


### 16. 다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
public class Main {

    public static void main(String[] args) {

        int[] data = {3, 5, 8, 12, 17};

        System.out.println(func(data, 0, data.length - 1));

    }

    static int func(int[] a, int st, int end) {

        if (st >= end) return 0;

        int mid = (st + end) / 2;

        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));

    } 

}
```

> 20
> 
> 재귀 문제인데 아직 이해 못함

### 17. 다음은 파이썬에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.


```
class Node:

    def __init__(self, value):

        self.value = value

        self.children = []

def tree(li):

    nodes = [Node(i) for i in li]

    for i in range(1, len(li)):

        nodes[(i - 1) // 2].children.append(nodes[i])

    return nodes[0]

def calc(node, level=0):

    if node is None:

        return 0

    return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)

li = [3, 5, 8, 12, 15, 18, 21]

root = tree(li)

print(calc(root))
```

> 첫번재 root = tree(li)는 이진 트리 구조로 생성한다.
> li의 개수는 7개이며
> 트리 구조는
```
		3
	   / \
	  5   8
     / \ / \
    12 1518 21
```

> calc는 재귀함수로 자식 노드가 끝날때까지 합산을 계산
> calc(node(3), 0)
> -> level이 홀수가 아니므로 0 + (calc(5, 1) + calc(8, 1))
> calc(5, 1)
> -> level이 홀수 이므로 5 + (calc(12, 2) + calc(15, 2))
> calc(8, 1)
> -> level이 홀수 이므로 5 + (calc(18, 2) + calc(21, 2))
> (calc(12, 2) + calc(15, 2)), (calc(18, 2) + calc(21, 2))
> -> level이 홀수가 아니고 마지막 노드이므로 0
> 따라서 5 + 8인 13이 정답

### 19.다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
#include <stdio.h>

typedef struct student {

    char* name;

    int score[3];

} Student;

int dec(int enc) {

    return enc & 0xA5;

}

int sum(Student* p) {

    return dec(p->score[0]) + dec(p->score[1]) + dec(p->score[2]);

}

int main() {

    Student s[2] = { "Kim", {0xA0, 0xA5, 0xDB}, "Lee", {0xA0, 0xED, 0x81} };

    Student* p = s;

    int result = 0;

    for (int i = 0; i < 2; i++) {

        result += sum(&s[i]);

    }

    printf("%d", result);

    return 0;

}
```

```
## **공통 마스크**

- 0xA5 = **1010 0101(2진수)**
    

  

## **Kim의 점수**

- score = { 0xA0, 0xA5, 0xDB }
    
    - 0xA0 & 0xA5
        
        - 0xA0 = 1010 0000
            
        - 0xA5 = 1010 0101
            
        - AND  = 1010 0000 = **0xA0 = 160**
            
        
    - 0xA5 & 0xA5 = **0xA5 = 165**
        
    - 0xDB & 0xA5
        
        - 0xDB = 1101 1011
            
        - 0xA5 = 1010 0101
            
        - AND   = 1000 0001 = **0x81 = 129**
            
        
    
- Kim 합: **160 + 165 + 129 = 454**
    

  

## **Lee의 점수**

- score = { 0xA0, 0xED, 0x81 }
    
    - 0xA0 & 0xA5 = **0xA0 = 160**
        
    - 0xED & 0xA5
        
        - 0xED = 1110 1101
            
        - 0xA5 = 1010 0101
            
        - AND   = 1010 0101 = **0xA5 = 165**
            
        
    - 0x81 & 0xA5
        
        - 0x81 = 1000 0001
            
        - 0xA5 = 1010 0101
            
        - AND   = 1000 0001 = **0x81 = 129**
            
        
    
- Lee 합: **160 + 165 + 129 = 454**
    

  

## **최종 결과**

- result = 454 (Kim) + 454 (Lee) = **908**
    
- 출력: 908
```

### 20. 다음은 Java 코드에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```
public class Main {

  public static void main(String[] args) {

    System.out.println(calc("5"));

  }

  static int calc(int value) {

    if (value <= 1) return value;

    return calc(value - 1) + calc(value - 2);

  }

  static int calc(String str) {

    int value = Integer.valueOf(str);

    if (value <= 1) return value;

    return calc(value - 1) + calc(value - 3);

  }

}
```

> 재귀함수 문제
> 처음 입력받는 calc("5"); 이므로
> 오버로딩되어 있는 calc(String str) 함수로 이동

```
		1. value = 5
		   return calc(4) + calc(2)
		2. value = 4
		   return calc(3) + calc(2)
		   value = 2
		   return calc(1) + calc(0)
		3. value = 3
		   return calc(2) + calc(1)
		   value = 2
		   return calc(1) + calc(0)
		   value = 1
		   return 1
		   value = 0
		   return 0
		4. value = 2
		   return calc(1) + calc(0)
		   value = 1
		   return 1
		   value = 1
		   return 1
		   value = 0
		   return 0
		5. value = 1
		   return 1
```
> 즉 나머지 return 값 1의 합산 4

**디자인 패턴**

소프트웨어공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴

디자인 패턴을 참고해서 개발할 경우 개발의 효율성과 유지보수성, 운용성이 높아지고 프로그램의 최적화에 도움이 된다.

디자인 패턴의 3가지 요소 : 생성, 구조, 행위

## 생성 패턴

객체의 인스턴스 생성에 관여하고 클래스 정의와 객체 생성 방식을 구조화, 캡슐화 하는 패턴

**어떻게 객체를 만들까에 대한 과정**

- Builder (빌더) : 생성 단계를 캡슐화 해서 구축 공정을 동일하게 이용하도록 하는 패턴 (조립식 생성)
- Prototype (프로토타입) : 기존 객체를 복제해서 새 객체를 생성할 수 있도록 하는 패턴 (기존 객체를 복제하여 새 객체 생성)
- Factory Method (팩토리 메서드) : 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고 하위 클래스에서 인스턴스를 생성하는 패턴 (객체 생성 분리) (부모는 틀만 제공하고 자식이 실제 객체를 생성)
- Abstract Factory (추상 팩토리) : 생성군들을 하나에 모아놓고 팩토리 중에서 선택하게 하는 패턴 (관련 객체 세트를 묶어 생성)
- Singletion (싱글톤) : 유일한 하나의 인스턴스를 보장하도록 하는 패턴 (하나의 인스턴스만 생성)

대표 패턴 : Singletion, Factory, Builder



## 구조 패턴

**객체를 어떻게 연결할까?에 대한 과정**

- Bridge (브릿지) : 추상과 구현을 분리해서 결합도를 낮춘 패턴 (분리)
- Decorator (데코레이터) : 소스를 변경하지 않고 기능을 확장하는 패턴 (덧씌우기)
- Facade (퍼싸드) : 하나의 인터페이스를 통해 느슨한 결합을 제공하는 패턴 (간소화)
- Flyweight (플라이웨이트) : 대량의 작은 객체들을 공유하는 패턴 (공유)
- Proxy (프록시) : 대리인이 대신 그 일을 처리하는 패턴 (대리)
- Composite (컴포지트) : 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴 (트리)
- Adapter (어뎁터) : 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴 (변환)

대표 패턴 : Adapter, Decorator, Proxy

## 행위 패턴

**객체끼리 어떻게 소통시킬까?에 대한 과정**

- Interpreter (통역사) : 언어 규칙 클래스를 이용하는 패턴
- Templete Method (템플릿 메서드) : 알고리즘 골격의 구조를 정의한 패턴 (뼈대를 고정)
- Chain of Responsibility : 객체끼리 연결 고리를 만들어 내부적으로 전달하는 패턴 (책임을 전달)
- Command (커멘드) : 요청 자체를 캡슐화해 파라미터로 넘기는 패턴 (요청을 캡슐화)
- Iterator : 내부 표현은 보여주지 않고 순회하는 패턴 (순회자)
- Mediator (중재자) : 객체 간 상호작용을 캡슐화한 패턴 (중재자)
- Memento (메멘토) : 상태 값을 미리 저장해두었다가 복구하는 패턴 (상태를 저장)
- Observer (옵저버) : 상태가 변할 때 의존자들에게 알리고 자동으로 업데이트하는 패턴 (이벤트 알림 구조)(자동으로 통보)
- State (상태) : 객체 내부 상태에 따라서 행위를 변경하는 패턴 (상태 변화)
- Strategy (전략) : 다양한 알고리즘을 캡슐화해 알고리즘 대체가 가능하도록 하는 패턴 (알고리즘 교체) 
- Visitor (방문자) : 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴 (기능을 추가)

대표 패턴 : Observer, Strategy, Template


생성 : 싱팩추빌프
구조 : 어브컴데파플프
행위 : 옵전상템커






